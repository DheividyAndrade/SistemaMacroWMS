# main.py
import customtkinter as ctk
import tkinter as tk
import threading
import os
import sys
import pyautogui
import time
from datetime import datetime
from google.oauth2 import service_account
from googleapiclient.discovery import build
from PIL import Image, ImageTk



# from imagesearch import telainicial  # Removido devido a erro de importa√ß√£o

# Importando fun√ß√µes do WMS

from functions.funcoes import (
    verificar_empdoc,
    verificar_uz_faltando,
    coletor,
    reconferir_uz,
    etiqueta_uz,
    etiqueta_variadas,
    Associar,
    Cadastro_Motorista,
    reservar,
    Liberar_EMP,
    Expedi√ß√£o,
    recebimento,
    finalizar_recebimento,
    finalizar_expedicao,
    Cancelamento_Pedido,
    verificar_BLOK_AVA,
    finalizar_faturamento,
    Erro_Motorista,
    Desbloquear_UZ,
    login_porta_admim,
    faturar_stine,
)

IMAGEM_ALVO = os.path.join("image", "logo.jpg")




# ========== SPLASH SCREEN ==========
def executar_api():
    os.system('python api/api.py')

def mostrar_splash():
    splash = tk.Tk()
    splash.overrideredirect(True)
    splash.geometry("400x300+500+300")  # Centraliza
    splash.configure(bg="black")

    try:
        imagem = Image.open(IMAGEM_ALVO)
        imagem = imagem.resize((100, 100))
        imagem_tk = ImageTk.PhotoImage(imagem)
        label_img = tk.Label(splash, image=imagem_tk, bg="black")
        label_img.image = imagem_tk
        label_img.pack(pady=(30, 10))
    except Exception as e:
        print("Erro ao carregar imagem:", e)

    tk.Label(splash, text="DH Scripts", font=(
        "Helvetica", 24, "bold"), fg="white", bg="black").pack()
    tk.Label(splash, text="Iniciando...", font=("Helvetica", 12),
             fg="gray", bg="black").pack(pady=(10, 0))
    # Contato no canto inferior direito
    contato_label = tk.Label(splash, text="Cel. (82) 99121-7317",
                             font=("Helvetica", 10),
                             fg="white", bg="black")
    contato_label.place(relx=1.0, rely=1.0, anchor="se", x=-10, y=-10)

    def fechar():
        splash.destroy()

    splash.after(5000, fechar)
    splash.mainloop()


# ========== IN√çCIO DO PROGRAMA ==========
mostrar_splash()

# ========== FUN√á√ïES AUXILIARES ==========


def carregar_credenciais():
    if not os.path.exists(ARQUIVO_CREDENCIAIS):
        pyautogui.alert(
            f"Arquivo de credenciais '{ARQUIVO_CREDENCIAIS}' n√£o encontrado.")
        return None
    try:
        creds = service_account.Credentials.from_service_account_file(
            ARQUIVO_CREDENCIAIS)
        service = build('sheets', 'v4', credentials=creds)
        return service
    except Exception as e:
        pyautogui.alert(f"Erro ao carregar as credenciais do Google:\n{e}")
        return None


def verificar_chave(chave_usuario):
    service = carregar_credenciais()
    if not service:
        return False
    try:
        sheet = service.spreadsheets()
        resultado = sheet.values().get(spreadsheetId=ID_PLANILHA,
                                       range=f"{NOME_ABA}!A2:C").execute()
        valores = resultado.get('values', [])

        for linha in valores:
            if len(linha) >= 3:
                chave, status, data_expiracao = linha[0].strip(
                ), linha[1].strip().lower(), linha[2].strip()
                if chave_usuario.strip() == chave and status == 'sim':
                    try:
                        data_exp = datetime.strptime(
                            data_expiracao, "%Y-%m-%d").date()
                        hoje = datetime.now().date()
                        if hoje <= data_exp:
                            return True
                        else:
                            pyautogui.alert("‚ùå Chave expirada.")
                            return False
                    except ValueError:
                        pyautogui.alert(
                            f"‚ö†Ô∏è Data inv√°lida para a chave '{chave}'.")
                        return False
        return False
    except Exception as e:
        pyautogui.alert(f"Erro ao acessar a planilha:\n{e}")
        return False


def salvar_chave_local(chave):
    with open(ARQUIVO_CHAVE_SALVA, 'w') as f:
        f.write(chave)

# ========== VERIFICA√á√ÉO DA CHAVE ==========


chave_digitada = pyautogui.prompt("üîê Digite sua chave de acesso:")

if not chave_digitada:
    pyautogui.alert("‚ùå Nenhuma chave foi digitada. Encerrando.")
    sys.exit()

if verificar_chave(chave_digitada):
    salvar_chave_local(chave_digitada)
    pyautogui.alert("‚úÖ Chave v√°lida! Bot liberado!")
else:
    pyautogui.alert("‚ùå Chave inv√°lida, inativa ou expirada. Bot bloqueado.")
    sys.exit()

time.sleep(1)  # Pequena pausa antes de iniciar o bot


# Configurar CustomTkinter
ctk.set_appearance_mode("Dark")
ctk.set_default_color_theme("blue")


def criar_interface():
    root = ctk.CTk()
    root.title("Automa√ß√£o WMS")
    root.geometry("450x650")

    # Frame principal
    main_frame = ctk.CTkFrame(root)
    main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

    # Dicion√°rio de fun√ß√µes (agora dividido em p√°ginas)
    paginas_funcoes = [
        # P√°gina 1
        {
            "Verificar EMPDOC ‚ùî": verificar_empdoc,
            "Verificar UZ Faltando ‚ùî": verificar_uz_faltando,
            "Associar üìà": Associar,
            "Cadastro Motorista üöö": Cadastro_Motorista,
            "Reservar üì¶": reservar,
            "Coletor üìü": coletor,
            "Reconferir UZ ‚Ü™Ô∏è": reconferir_uz,
            "Etiqueta UZ üè∑Ô∏è": etiqueta_uz,
            "Etiqueta Variadas üè∑Ô∏è": etiqueta_variadas,
            "Liberar EMP ‚úÖ": Liberar_EMP,
            "Expedi√ß√£o ‚≠ê": Expedi√ß√£o,
            "recebimento ‚≠ê": recebimento,
            "Finalizar Recebimento ‚ñ∂Ô∏è": finalizar_recebimento,
            "Finalizar Expedicao ‚ñ∂Ô∏è": finalizar_expedicao,
            "Finalizar Faturamento ‚ñ∂Ô∏è": finalizar_faturamento,

        },
        # P√°gina 2
        {
            "Desbloquear UZ üîì": Desbloquear_UZ,
            "Verificar Blokc AVA ‚ùî": verificar_BLOK_AVA,
            "Erro Motorista ‚ùó": Erro_Motorista,
            "Cancelamento Pedido ‚ùå": Cancelamento_Pedido,
            "Faturar Stine üí≤": faturar_stine,
            "Login Porta Admin üîë": login_porta_admim,
        }
    ]

    # Vari√°vel para controlar a p√°gina atual
    pagina_atual = ctk.IntVar(value=0)

    # Label de t√≠tulo
    label = ctk.CTkLabel(main_frame, text="Selecione a fun√ß√£o:",
                         font=ctk.CTkFont(size=16, weight="bold"))
    label.pack(pady=10)

    # Container para a √°rea scroll√°vel (com altura fixa)
    container_scroll = ctk.CTkFrame(main_frame)
    container_scroll.pack(fill=tk.BOTH, expand=True, pady=10)
    # Impede que o container redimensione
    container_scroll.pack_propagate(False)

    # Configurar altura do container scroll√°vel
    container_scroll.configure(height=450)

    # Canvas para scrolling
    canvas = tk.Canvas(container_scroll, highlightthickness=0, bg='#2b2b2b')
    scrollbar = ctk.CTkScrollbar(
        container_scroll, orientation="vertical", command=canvas.yview)

    # Frame scroll√°vel que vai dentro do canvas
    scrollable_frame = ctk.CTkFrame(canvas)

    # Configurar o sistema de scroll
    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    # Colocar o frame scroll√°vel no canvas
    canvas.create_window((0, 0), window=scrollable_frame,
                         anchor="nw", width=canvas.winfo_reqwidth())
    canvas.configure(yscrollcommand=scrollbar.set)

    # Frame para os bot√µes
    botoes_frame = ctk.CTkFrame(scrollable_frame)
    botoes_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

    # Empacotar canvas e scrollbar
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    # Fun√ß√£o para scroll com mouse
    def on_mousewheel(event):
        canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    # Vincular evento de scroll apenas ao canvas
    canvas.bind("<MouseWheel>", on_mousewheel)

    # Frame para navega√ß√£o (FORA do container scroll√°vel)
    navegacao_frame = ctk.CTkFrame(main_frame)
    navegacao_frame.pack(side=tk.BOTTOM, pady=10, fill=tk.X)

    # Bot√£o p√°gina anterior
    btn_anterior = ctk.CTkButton(navegacao_frame, text="‚Üê", width=40,
                                 command=lambda: [pagina_atual.set(pagina_atual.get() - 1), atualizar_pagina()])
    btn_anterior.pack(side=tk.LEFT, padx=10)

    # Indicador de p√°gina
    pagina_label = ctk.CTkLabel(
        navegacao_frame, text="", font=ctk.CTkFont(size=12))
    pagina_label.pack(side=tk.LEFT, padx=10)

    # Bot√£o pr√≥xima p√°gina
    btn_proximo = ctk.CTkButton(navegacao_frame, text="‚Üí", width=40,
                                command=lambda: [pagina_atual.set(pagina_atual.get() + 1), atualizar_pagina()])
    btn_proximo.pack(side=tk.LEFT, padx=10)

    # Fun√ß√£o para atualizar a p√°gina
    def atualizar_pagina():
        # Limpa frame atual
        for widget in botoes_frame.winfo_children():
            widget.destroy()

        # Adiciona bot√µes da p√°gina atual
        funcoes = paginas_funcoes[pagina_atual.get()]
        for nome, func in funcoes.items():
            btn = ctk.CTkButton(botoes_frame, text=nome, width=300,
                                height=35, command=lambda f=func: threading.Thread(target=f).start())
            btn.pack(pady=8)

        # Atualiza indicador de p√°gina
        pagina_label.configure(
            text=f"P√°gina {pagina_atual.get() + 1}/{len(paginas_funcoes)}")

        # Configura estado dos bot√µes de navega√ß√£o
        if pagina_atual.get() == 0:
            btn_anterior.configure(state="disabled")
        else:
            btn_anterior.configure(state="normal")

        if pagina_atual.get() == len(paginas_funcoes) - 1:
            btn_proximo.configure(state="disabled")
        else:
            btn_proximo.configure(state="normal")

        # Atualizar o scroll ap√≥s adicionar os bot√µes
        root.update_idletasks()
        canvas.configure(scrollregion=canvas.bbox("all"))

    # Ajustar largura do canvas quando o container for redimensionado
    def ajustar_largura_canvas(event):
        canvas.itemconfig("all", width=event.width)
        canvas.configure(width=event.width)

    scrollable_frame.bind("<Configure>", ajustar_largura_canvas)

    # Inicializa primeira p√°gina
    atualizar_pagina()

    root.mainloop()


if __name__ == "__main__":
    criar_interface()
